<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>땅따묵기</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      overscroll-behavior: none;
    }
    body {
      min-height: 100vh;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%, #000 100%);
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none;
    }
    .wrap {
      max-width: 960px;
      width: 100%;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.04em;
    }
    .hud {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 14px;
    }
    .badge {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.5);
      backdrop-filter: blur(8px);
    }
    .game-shell {
      position: relative;
      display: inline-block;
    }
    canvas {
      background: #020617;
      border-radius: 12px;
      border: 2px solid #4b5563;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
      image-rendering: pixelated;
      max-width: 100%;
      display: block;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .overlay-inner {
      pointer-events: auto;
      padding: 16px 24px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.7);
      text-align: center;
      min-width: 240px;
    }
    .overlay-title {
      font-size: 20px;
      margin-bottom: 4px;
    }
    .overlay-sub {
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 10px;
      white-space: pre-line;
    }
    .overlay-inner button {
      margin-top: 4px;
      padding: 6px 14px;
      border-radius: 999px;
      border: none;
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      cursor: pointer;
    }
    .start-layer {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .start-inner {
      pointer-events: auto;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(55,65,81,0.8);
    }
    #nicknameInput {
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #e5e7eb;
      font-size: 13px;
      min-width: 140px;
      outline: none;
    }
    #nicknameInput::placeholder {
      color: #6b7280;
    }
    #startButton,
    #localRankButton {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.6);
      white-space: nowrap;
    }
    #startButton {
      background: #22c55e;
      color: #022c22;
    }
    #startButton:hover { filter: brightness(1.05); }
    #localRankButton {
      background: #0ea5e9;
      color: #0f172a;
    }
    #localRankButton:hover { filter: brightness(1.05); }

    .joystick {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      touch-action: none;
    }
    .stick-base {
      width: 160px;
      height: 160px;
      border-radius: 999px;
      background: radial-gradient(circle at top, #111827, #020617);
      border: 2px solid #4b5563;
      position: relative;
      box-shadow: 0 10px 25px rgba(0,0,0,0.6);
      touch-action: none;
    }
    .stick-handle {
      width: 80px;
      height: 80px;
      border-radius: 999px;
      background: radial-gradient(circle at top, #0f172a, #020617);
      border: 2px solid #9ca3af;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 6px 18px rgba(15,23,42,0.8);
      touch-action: none;
    }

    .item-legend {
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(15,23,42,0.85);
      border: 1px solid rgba(55,65,81,0.8);
      font-size: 12px;
      max-width: 640px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }
    .legend-item:last-child { margin-bottom: 0; }
    .legend-icon {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .legend-text { color: #e5e7eb; }

    .hint {
      font-size: 13px;
      color: #9ca3af;
      text-align: center;
      max-width: 640px;
    }
    .hint kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid #6b7280;
      font-size: 11px;
      background: rgba(15, 23, 42, 0.9);
    }

    #restartBtn {
      margin-top: 4px;
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      box-shadow: 0 10px 25px rgba(34, 197, 94, 0.4);
      display: none;
    }
    #restartBtn:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
    }
    #restartBtn:active {
      transform: translateY(0);
      box-shadow: 0 6px 18px rgba(34, 197, 94, 0.35);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>땅따묵기</h1>
    <div class="hud">
      <div class="badge">스테이지: <span id="stage">1</span></div>
      <div class="badge">점수: <span id="score">0</span></div>
      <div class="badge">채운 땅: <span id="fill">0</span>%</div>
      <div class="badge">목표: <span id="target">90</span>%</div>
      <div class="badge">목숨: <span id="lives">3</span></div>
    </div>

    <div class="game-shell">
      <canvas id="game" width="640" height="640"></canvas>

      <div class="overlay" id="overlay">
        <div class="overlay-inner">
          <div class="overlay-title" id="overlayTitle">게임 종료</div>
          <div class="overlay-sub" id="overlaySub"></div>
          <button id="overlayRestart">확인</button>
        </div>
      </div>

      <div class="start-layer" id="startLayer">
        <div class="start-inner">
          <input id="nicknameInput" maxlength="12" placeholder="닉네임 입력" />
          <button id="startButton">게임 시작</button>
          <button id="localRankButton">로컬 등수</button>
        </div>
      </div>
    </div>

    <div class="joystick" id="joystickArea">
      <div class="stick-base">
        <div class="stick-handle" id="stickHandle"></div>
      </div>
    </div>

    <div class="item-legend">
      <div class="legend-item">
        <span class="legend-icon">⚡</span>
        <span class="legend-text">속도 버프: 30초 동안 게임 속도 +10%</span>
      </div>
      <div class="legend-item">
        <span class="legend-icon">❤</span>
        <span class="legend-text">목숨 +1: 현재 남은 목숨이 1 증가</span>
      </div>
      <div class="legend-item">
        <span class="legend-icon">!</span>
        <span class="legend-text">위험: 1적(빨간 원형 적) 1마리가 추가 등장</span>
      </div>
    </div>

    <div class="hint">
      <p>
        <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> 또는 <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> 로 이동하고,<br />
        화면의 90%를 채우면 다음 스테이지로 진행해.<br />
        스테이지 1~3을 모두 클리어하면 진짜 보상(?)이 기다리고 있어.
      </p>
    </div>

    <button id="restartBtn">처음부터 다시</button>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const cols = 80;
      const rows = 80;
      const cellSize = canvas.width / cols;

      const MIN_SPEED = 4;
      const MAX_SPEED = 5;
      const SPEED_TYPE2 = 2;

      const TARGET_PERCENT = 90;
      const MAX_LIVES = 3;
      const BUFF_DURATION = 30000;
      const SPEED_BUFF_FACTOR = 1.1;

      const stageEl = document.getElementById("stage");
      const scoreEl = document.getElementById("score");
      const fillEl = document.getElementById("fill");
      const targetEl = document.getElementById("target");
      const livesEl = document.getElementById("lives");
      const restartBtn = document.getElementById("restartBtn");

      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlaySub = document.getElementById("overlaySub");
      const overlayRestart = document.getElementById("overlayRestart");

      const startLayer = document.getElementById("startLayer");
      const startButton = document.getElementById("startButton");
      const localRankButton = document.getElementById("localRankButton");
      const nicknameInput = document.getElementById("nicknameInput");

      const joystickArea = document.getElementById("joystickArea");
      const joystickHandle = document.getElementById("stickHandle");

      let couponCanvas = null;
      let couponCtx = null;
      let lastCouponStage = null;

      targetEl.textContent = TARGET_PERCENT;

      let board;
      let player;
      let enemies = [];
      let items = [];

      let lastTime = 0;
      let moveTimer = 0;
      let lastHasInput = false;
      const MOVE_INTERVAL = 16;
      const PLAYER_SPEED = 0.8;
      let playerMoveAccum = 0;

      let score = 0;
      let lives = MAX_LIVES;
      let stage = 1;
      let running = false;
      let pendingAction = null;

      let speedBuffRemaining = 0;

      const keys = {
        left: false,
        right: false,
        up: false,
        down: false
      };

      function setDirFlag(dir, pressed) {
        if (dir === "left") keys.left = pressed;
        else if (dir === "right") keys.right = pressed;
        else if (dir === "up") keys.up = pressed;
        else if (dir === "down") keys.down = pressed;
      }

      function bindJoystick() {
        if (!joystickArea || !joystickHandle) return;

        const base = joystickArea.querySelector(".stick-base");
        if (!base) return;

        let active = false;
        function resetStick() {
          joystickHandle.style.left = "50%";
          joystickHandle.style.top = "50%";
          keys.up = keys.down = keys.left = keys.right = false;
        }

        function getRect() {
          return base.getBoundingClientRect();
        }

        function updateFromPoint(clientX, clientY) {
          const rect = getRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          let dx = clientX - centerX;
          let dy = clientY - centerY;

          const maxR = rect.width / 2;
          const len = Math.hypot(dx, dy);

          if (len < maxR * 0.2) {
            resetStick();
            return;
          }

          const clampedLen = Math.min(len, maxR * 0.9);
          const nx = dx / (len || 1);
          const ny = dy / (len || 1);
          const px = centerX + nx * clampedLen;
          const py = centerY + ny * clampedLen;

          joystickHandle.style.left = ((px - rect.left) / rect.width * 100) + "%";
          joystickHandle.style.top = ((py - rect.top) / rect.height * 100) + "%";

          let angle = Math.atan2(ny, nx);
          let deg = angle * 180 / Math.PI;
          if (deg < 0) deg += 360;

          keys.up = keys.down = keys.left = keys.right = false;

          if (deg >= 337.5 || deg < 22.5) {
            keys.right = true;
          } else if (deg >= 22.5 && deg < 67.5) {
            keys.right = true;
            keys.down = true;
          } else if (deg >= 67.5 && deg < 112.5) {
            keys.down = true;
          } else if (deg >= 112.5 && deg < 157.5) {
            keys.down = true;
            keys.left = true;
          } else if (deg >= 157.5 && deg < 202.5) {
            keys.left = true;
          } else if (deg >= 202.5 && deg < 247.5) {
            keys.left = true;
            keys.up = true;
          } else if (deg >= 247.5 && deg < 292.5) {
            keys.up = true;
          } else if (deg >= 292.5 && deg < 337.5) {
            keys.up = true;
            keys.right = true;
          }
        }

        function getPoint(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }

        base.addEventListener("mousedown", (e) => {
          e.preventDefault();
          active = true;
          const p = getPoint(e);
          updateFromPoint(p.x, p.y);
        });

        base.addEventListener("touchstart", (e) => {
          e.preventDefault();
          active = true;
          const p = getPoint(e);
          updateFromPoint(p.x, p.y);
        }, { passive: false });

        window.addEventListener("mousemove", (e) => {
          if (!active) return;
          e.preventDefault();
          const p = getPoint(e);
          updateFromPoint(p.x, p.y);
        });

        window.addEventListener("touchmove", (e) => {
          if (!active) return;
          e.preventDefault();
          const p = getPoint(e);
          updateFromPoint(p.x, p.y);
        }, { passive: false });

        function endInteraction(e) {
          if (!active) return;
          e.preventDefault();
          active = false;
          resetStick();
        }

        window.addEventListener("mouseup", endInteraction);
        window.addEventListener("touchend", endInteraction, { passive: false });
        window.addEventListener("touchcancel", endInteraction, { passive: false });

        resetStick();
      }

      function getInputDir() {
        let dx = 0;
        let dy = 0;
        if (keys.left && !keys.right) dx = -1;
        else if (keys.right && !keys.left) dx = 1;
        if (keys.up && !keys.down) dy = -1;
        else if (keys.down && !keys.up) dy = 1;
        return { x: dx, y: dy };
      }

      function createEmptyBoard() {
        const b = [];
        for (let y = 0; y < rows; y++) {
          const row = [];
          for (let x = 0; x < cols; x++) {
            if (y === 0 || y === rows - 1 || x === 0 || x === cols - 1) {
              row.push(1);
            } else {
              row.push(0);
            }
          }
          b.push(row);
        }
        return b;
      }

      function resetPlayer() {
        player = {
          x: 1,
          y: 0,
          drawing: false,
          trail: []
        };
        playerMoveAccum = 0;
        keys.left = keys.right = keys.up = keys.down = false;
      }

      function randomSpeedBetween() {
        return MIN_SPEED + Math.random() * (MAX_SPEED - MIN_SPEED);
      }

      function spawnEnemiesForStage(stageNum) {
        enemies = [];
        const baseR1 = cellSize * 2.2;
        const baseR2 = baseR1 * 2.5;

        function spawnType1(count) {
          for (let i = 0; i < count; i++) {
            const ex = 2 + Math.floor(Math.random() * (cols - 4));
            const ey = 2 + Math.floor(Math.random() * (rows - 4));
            const speed = randomSpeedBetween();
            const angle = Math.random() * Math.PI * 2;
            enemies.push({
              type: 1,
              radius: baseR1,
              x: ex * cellSize + cellSize / 2,
              y: ey * cellSize + cellSize / 2,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed
            });
          }
        }

        function spawnType2(count) {
          for (let i = 0; i < count; i++) {
            const ex = 2 + Math.floor(Math.random() * (cols - 4));
            const ey = 2 + Math.floor(Math.random() * (rows - 4));
            const angle = Math.random() * Math.PI * 2;
            enemies.push({
              type: 2,
              radius: baseR2,
              x: ex * cellSize + cellSize / 2,
              y: ey * cellSize + cellSize / 2,
              vx: Math.cos(angle) * SPEED_TYPE2,
              vy: Math.sin(angle) * SPEED_TYPE2
            });
          }
        }

        if (stageNum === 1) {
          spawnType1(2);
        } else if (stageNum === 2) {
          spawnType1(3);
          spawnType2(1);
        } else if (stageNum === 3) {
          spawnType1(4);
          spawnType2(2);
        }
      }

      function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
        }
      }

      function spawnItemsForStage() {
        items = [];
        const types = ["speed", "life", "enemy"];
        shuffleArray(types);
        const chosen = types.slice(0, 2);

        for (const t of chosen) {
          let placed = false;
          for (let tries = 0; tries < 100 && !placed; tries++) {
            const rx = 2 + Math.floor(Math.random() * (cols - 4));
            const ry = 2 + Math.floor(Math.random() * (rows - 4));
            if (board[ry][rx] !== 0) continue;
            if (items.some(it => it.x === rx && it.y === ry)) continue;
            items.push({ x: rx, y: ry, type: t });
            placed = true;
          }
        }
      }

      function setupStage(stageNum, resetScoreAndLives) {
        if (resetScoreAndLives) {
          score = 0;
          lives = MAX_LIVES;
          speedBuffRemaining = 0;
        }
        board = createEmptyBoard();
        resetPlayer();
        spawnEnemiesForStage(stageNum);
        spawnItemsForStage();
        updateHUD(getFillPercent());
      }

      function startNewGame() {
        stage = 1;
        stageEl.textContent = stage;
        overlay.style.display = "none";
        restartBtn.style.display = "none";
        startLayer.style.display = "flex";
        running = false;
        pendingAction = null;
        setupStage(stage, true);
      }

      function updateHUD(fillPercent) {
        stageEl.textContent = stage;
        scoreEl.textContent = score;
        fillEl.textContent = fillPercent.toFixed(0);
        livesEl.textContent = lives;
      }

      function beginPlayIfReady() {
        if (!running) {
          running = true;
          startLayer.style.display = "none";
        }
      }

      document.addEventListener("keydown", function (e) {
        if (e.key === " " && !running && startLayer.style.display !== "none") {
          e.preventDefault();
          beginPlayIfReady();
          return;
        }
        if (e.key === "ArrowLeft" || e.key === "a") {
          e.preventDefault();
          setDirFlag("left", true);
        }
        if (e.key === "ArrowRight" || e.key === "d") {
          e.preventDefault();
          setDirFlag("right", true);
        }
        if (e.key === "ArrowUp" || e.key === "w") {
          e.preventDefault();
          setDirFlag("up", true);
        }
        if (e.key === "ArrowDown" || e.key === "s") {
          e.preventDefault();
          setDirFlag("down", true);
        }
      });

      document.addEventListener("keyup", function (e) {
        if (e.key === "ArrowLeft" || e.key === "a") {
          e.preventDefault();
          setDirFlag("left", false);
        }
        if (e.key === "ArrowRight" || e.key === "d") {
          e.preventDefault();
          setDirFlag("right", false);
        }
        if (e.key === "ArrowUp" || e.key === "w") {
          e.preventDefault();
          setDirFlag("up", false);
        }
        if (e.key === "ArrowDown" || e.key === "s") {
          e.preventDefault();
          setDirFlag("down", false);
        }
      });

      startButton.addEventListener("click", function () {
        beginPlayIfReady();
      });

      restartBtn.addEventListener("click", function () {
        startNewGame();
      });

      overlayRestart.addEventListener("click", function () {
        overlay.style.display = "none";
        if (pendingAction === "stage2") {
          stage = 2;
          setupStage(stage, false);
          running = true;
        } else if (pendingAction === "stage3") {
          stage = 3;
          setupStage(stage, false);
          running = true;
        } else if (pendingAction === "restart") {
          startNewGame();
        }
        pendingAction = null;
      });

      localRankButton.addEventListener("click", function () {
        showLocalRank();
      });

      function blockedPixel(px, py, radius) {
        const steps = 18;
        for (let i = 0; i < steps; i++) {
          const ang = (Math.PI * 2 * i) / steps;
          const sx = px + Math.cos(ang) * radius;
          const sy = py + Math.sin(ang) * radius;
          const cx = Math.floor(sx / cellSize);
          const cy = Math.floor(sy / cellSize);
          if (cx < 0 || cx >= cols || cy < 0 || cy >= rows) return true;
          const v = board[cy][cx];
          if (v === 1) return true;
        }
        return false;
      }

      function randomBounceTowardPlayer(enemy) {
        const px = (player.x + 0.5) * cellSize;
        const py = (player.y + 0.5) * cellSize;
        let dx = px - enemy.x;
        let dy = py - enemy.y;
        let len = Math.hypot(dx, dy);
        if (!len) {
          dx = 1;
          dy = 0;
          len = 1;
        }
        dx /= len;
        dy /= len;
        const baseAngle = Math.atan2(dy, dx);
        const maxAngle = Math.PI / 3;
        const offset = (Math.random() * 2 - 1) * maxAngle;
        const angle = baseAngle + offset;

        let speed;
        if (enemy.type === 2) {
          speed = SPEED_TYPE2;
        } else {
          speed = randomSpeedBetween();
        }
        return {
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed
        };
      }

      function update(dt) {
        if (!running) {
          return;
        }

        if (speedBuffRemaining > 0) {
          speedBuffRemaining = Math.max(0, speedBuffRemaining - dt);
        }
        const speedFactor = speedBuffRemaining > 0 ? SPEED_BUFF_FACTOR : 1.0;

        const dirNow = getInputDir();
        const hasInput = dirNow.x !== 0 || dirNow.y !== 0;

        if (hasInput && !lastHasInput) {
          moveTimer += MOVE_INTERVAL;
        }
        lastHasInput = hasInput;

        moveTimer += dt * speedFactor;
        const steps = Math.floor(moveTimer / MOVE_INTERVAL);
        if (steps <= 0) return;
        moveTimer -= steps * MOVE_INTERVAL;

        for (let i = 0; i < steps; i++) {
          stepPlayer();
          stepEnemies();
          checkCollisions();
        }
      }

      function stepPlayer() {
        const dir = getInputDir();
        const dx = dir.x;
        const dy = dir.y;
        if (dx === 0 && dy === 0) return;

        playerMoveAccum += PLAYER_SPEED;
        if (playerMoveAccum < 1) return;
        playerMoveAccum -= 1;

        const nx = player.x + dx;
        const ny = player.y + dy;
        if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return;

        const nextCell = board[ny][nx];

        if (!player.drawing) {
          if (nextCell === 1) {
            player.x = nx;
            player.y = ny;
          } else if (nextCell === 0) {
            player.drawing = true;
            player.x = nx;
            player.y = ny;
            player.trail = [{ x: nx, y: ny }];
            board[ny][nx] = 2;
          }
        } else {
          if (nextCell === 0) {
            player.x = nx;
            player.y = ny;
            player.trail.push({ x: nx, y: ny });
            board[ny][nx] = 2;
          } else if (nextCell === 1) {
            player.x = nx;
            player.y = ny;
            completeTrailAndFill();
          } else if (nextCell === 2) {
            loseLife();
          }
        }
      }

      function stepEnemies() {
        for (const enemy of enemies) {
          let nx = enemy.x + enemy.vx;
          let ny = enemy.y + enemy.vy;

          if (blockedPixel(nx, ny, enemy.radius)) {
            let tries = 0;
            let bounced = false;
            while (tries < 8) {
              const nd = randomBounceTowardPlayer(enemy);
              enemy.vx = nd.vx;
              enemy.vy = nd.vy;
              nx = enemy.x + enemy.vx;
              ny = enemy.y + enemy.vy;
              if (!blockedPixel(nx, ny, enemy.radius)) {
                bounced = true;
                break;
              }
              tries++;
            }
            if (!bounced) {
              enemy.vx = -enemy.vx;
              enemy.vy = -enemy.vy;
              nx = enemy.x + enemy.vx;
              ny = enemy.y + enemy.vy;
            }
          }

          enemy.x = nx;
          enemy.y = ny;

          if (enemy.x < cellSize) enemy.x = cellSize;
          if (enemy.x > canvas.width - cellSize) enemy.x = canvas.width - cellSize;
          if (enemy.y < cellSize) enemy.y = cellSize;
          if (enemy.y > canvas.height - cellSize) enemy.y = canvas.height - cellSize;

          if (blockedPixel(enemy.x, enemy.y, enemy.radius)) {
            for (let t = 0; t < 40; t++) {
              const ex = 2 + Math.floor(Math.random() * (cols - 4));
              const ey = 2 + Math.floor(Math.random() * (rows - 4));
              const rx = ex * cellSize + cellSize / 2;
              const ry = ey * cellSize + cellSize / 2;
              if (!blockedPixel(rx, ry, enemy.radius)) {
                enemy.x = rx;
                enemy.y = ry;
                break;
              }
            }
          }
        }

        for (let i = 0; i < enemies.length; i++) {
          for (let j = i + 1; j < enemies.length; j++) {
            const a = enemies[i];
            const b = enemies[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            const minDist = (a.radius + b.radius) * 0.9;
            if (dist > 0 && dist < minDist) {
              const tvx = a.vx;
              const tvy = a.vy;
              a.vx = b.vx;
              a.vy = b.vy;
              b.vx = tvx;
              b.vy = tvy;

              const overlap = (minDist - dist) / 2;
              const nxn = dx / dist;
              const nyn = dy / dist;
              a.x -= nxn * overlap;
              a.y -= nyn * overlap;
              b.x += nxn * overlap;
              b.y += nyn * overlap;
            }
          }
        }
      }

      function checkCollisions() {
        const playerRadius = cellSize * 0.9;
        const pcx = (player.x + 0.5) * cellSize;
        const pcy = (player.y + 0.5) * cellSize;

        for (const enemy of enemies) {
          const dx = enemy.x - pcx;
          const dy = enemy.y - pcy;
          const dist = Math.hypot(dx, dy);
          if (dist < enemy.radius + playerRadius * 0.8) {
            loseLife();
            return;
          }

          const steps = 24;
          for (let i = 0; i < steps; i++) {
            const ang = (Math.PI * 2 * i) / steps;
            const sx = enemy.x + Math.cos(ang) * enemy.radius;
            const sy = enemy.y + Math.sin(ang) * enemy.radius;
            const cx = Math.floor(sx / cellSize);
            const cy = Math.floor(sy / cellSize);
            if (cx < 0 || cx >= cols || cy < 0 || cy >= rows) continue;
            if (board[cy][cx] === 2) {
              loseLife();
              return;
            }
          }
        }
      }

      function clearTrail() {
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            if (board[y][x] === 2) board[y][x] = 0;
          }
        }
      }

      function getNickname() {
        if (!nicknameInput) return "플레이어";
        const name = nicknameInput.value.trim();
        if (!name) return "플레이어";
        return name;
      }

      function saveScoreIfNeeded() {
        if (score <= 0) return;
        if (!window.localStorage) return;
        let arr;
        try {
          arr = JSON.parse(localStorage.getItem("qixGiftLocalScores") || "[]");
        } catch (e) {
          arr = [];
        }
        const name = getNickname();
        arr.push({
          name: name,
          score: score,
          stage: stage,
          time: new Date().toISOString()
        });
        arr.sort((a, b) => b.score - a.score);
        if (arr.length > 30) arr = arr.slice(0, 30);
        localStorage.setItem("qixGiftLocalScores", JSON.stringify(arr));
      }

      function showLocalRank() {
        if (!window.localStorage) {
          alert("이 브라우저에서는 로컬 등수를 저장할 수 없어.");
          return;
        }
        let arr;
        try {
          arr = JSON.parse(localStorage.getItem("qixGiftLocalScores") || "[]");
        } catch (e) {
          arr = [];
        }
        if (!arr.length) {
          alert("아직 저장된 기록이 없어.");
          return;
        }
        const lines = arr.slice(0, 10).map((entry, idx) => {
          const dateStr = entry.time ? entry.time.slice(0, 10) : "";
          return (
            (idx + 1) +
            "위 - " +
            (entry.name || "플레이어") +
            " : " +
            entry.score +
            "점 (최종 스테이지 " +
            entry.stage +
            ", " +
            dateStr +
            ")"
          );
        });
        alert(lines.join("\n"));
      }

      function loseLife() {
        clearTrail();
        player.drawing = false;
        player.trail = [];
        lives -= 1;
        if (lives <= 0) {
          lives = 0;
          running = false;
          updateHUD(getFillPercent());
          saveScoreIfNeeded();
          restartBtn.style.display = "inline-block";
          showOverlay("게임 오버", "적이나 선에 닿았어… 다시 한 판?", "restart");
        } else {
          resetPlayer();
          spawnEnemiesForStage(stage);
          updateHUD(getFillPercent());
        }
      }

      function applyItem(type) {
        if (type === "speed") {
          speedBuffRemaining = BUFF_DURATION;
        } else if (type === "life") {
          lives += 1;
          updateHUD(getFillPercent());
        } else if (type === "enemy") {
          const baseR1 = cellSize * 2.2;
          let placed = false;
          for (let tries = 0; tries < 100 && !placed; tries++) {
            const ex = 2 + Math.floor(Math.random() * (cols - 4));
            const ey = 2 + Math.floor(Math.random() * (rows - 4));
            if (board[ey][ex] === 1) continue;
            const speed = randomSpeedBetween();
            const angle = Math.random() * Math.PI * 2;
            enemies.push({
              type: 1,
              radius: baseR1,
              x: ex * cellSize + cellSize / 2,
              y: ey * cellSize + cellSize / 2,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed
            });
            placed = true;
          }
        }
      }

      function completeTrailAndFill() {
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            if (board[y][x] === 2) board[y][x] = 1;
          }
        }
        player.drawing = false;
        player.trail = [];

        const compIndex = [];
        for (let y = 0; y < rows; y++) {
          compIndex.push(new Array(cols).fill(-1));
        }
        const compSizes = [];
        let compCount = 0;

        const dirs = [
          { x: 1, y: 0 },
          { x: -1, y: 0 },
          { x: 0, y: 1 },
          { x: 0, y: -1 }
        ];

        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            if (board[y][x] !== 0 || compIndex[y][x] !== -1) continue;
            const q = [{ x, y }];
            compIndex[y][x] = compCount;
            let size = 0;
            while (q.length) {
              const cur = q.shift();
              size++;
              for (const d of dirs) {
                const nx = cur.x + d.x;
                const ny = cur.y + d.y;
                if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) continue;
                if (board[ny][nx] !== 0) continue;
                if (compIndex[ny][nx] !== -1) continue;
                compIndex[ny][nx] = compCount;
                q.push({ x: nx, y: ny });
              }
            }
            compSizes.push(size);
            compCount++;
          }
        }

        let newlyClaimed = 0;

        if (compCount > 0) {
          let seaId = 0;
          let maxSize = compSizes[0];
          for (let i = 1; i < compCount; i++) {
            if (compSizes[i] > maxSize) {
              maxSize = compSizes[i];
              seaId = i;
            }
          }

          const enemyComp = new Array(enemies.length).fill(-1);
          for (let ei = 0; ei < enemies.length; ei++) {
            const enemy = enemies[ei];
            const cx = Math.floor(enemy.x / cellSize);
            const cy = Math.floor(enemy.y / cellSize);
            if (cx < 0 || cx >= cols || cy < 0 || cy >= rows) continue;
            enemyComp[ei] = compIndex[cy][cx];
          }

          const survivors = [];
          for (let ei = 0; ei < enemies.length; ei++) {
            const enemy = enemies[ei];
            const cx = Math.floor(enemy.x / cellSize);
            const cy = Math.floor(enemy.y / cellSize);
            if (cx < 0 || cx >= cols || cy < 0 || cy >= rows) continue;
            if (board[cy][cx] === 1 && enemyComp[ei] !== seaId && enemyComp[ei] !== -1) {
              score += 100;
            } else {
              survivors.push(enemy);
            }
          }
          enemies = survivors;

          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              if (board[y][x] === 0 && compIndex[y][x] !== seaId && compIndex[y][x] !== -1) {
                board[y][x] = 1;
                newlyClaimed++;
              }
            }
          }
        }

        if (items.length > 0) {
          const remainItems = [];
          for (const it of items) {
            if (board[it.y][it.x] === 1) {
              applyItem(it.type);
            } else {
              remainItems.push(it);
            }
          }
          items = remainItems;
        }

        if (newlyClaimed > 0) {
          score += newlyClaimed * 10;
        }

        const fillPercent = getFillPercent();
        updateHUD(fillPercent);

        const commonMsg = "이미 사용된 기프티콘입니다 ^^";
        if (fillPercent >= TARGET_PERCENT) {
          running = false;
          restartBtn.style.display = "inline-block";
          if (stage === 1) {
            showOverlay(
              "스테이지 1 클리어!",
              commonMsg + "\n(스타벅스 아메리카노 1잔 기프티콘)",
              "stage2"
            );
          } else if (stage === 2) {
            showOverlay(
              "스테이지 2 클리어!",
              commonMsg + "\n(스타벅스 아메리카노 + 디저트 세트 기프티콘)",
              "stage3"
            );
          } else {
            saveScoreIfNeeded();
            showOverlay(
              "스테이지 3 클리어!",
              "마지막 보상: 제작자가 밥 사줍니다.\n(이건 진짜야, 장난 아님)",
              "restart"
            );
          }
        }
      }

      function getFillPercent() {
        let filled = 0;
        let total = 0;
        for (let y = 1; y < rows - 1; y++) {
          for (let x = 1; x < cols - 1; x++) {
            total++;
            if (board[y][x] === 1) filled++;
          }
        }
        if (total === 0) return 0;
        return (filled / total) * 100;
      }

      function drawCouponBackground() {
        const w = canvas.width;
        const h = canvas.height;

        if (!couponCanvas || couponCanvas.width !== w || couponCanvas.height !== h || lastCouponStage !== stage) {
          couponCanvas = document.createElement("canvas");
          couponCanvas.width = w;
          couponCanvas.height = h;
          couponCtx = couponCanvas.getContext("2d");
          lastCouponStage = stage;

          const ctx2 = couponCtx;
          ctx2.clearRect(0, 0, w, h);
          ctx2.fillStyle = "#020617";
          ctx2.fillRect(0, 0, w, h);

          const margin = w * 0.08;
          const rx = margin;
          const ry = margin;
          const rw = w - margin * 2;
          const rh = h - margin * 2;

          function roundRect2(x, y, w2, h2, r) {
            ctx2.beginPath();
            ctx2.moveTo(x + r, y);
            ctx2.lineTo(x + w2 - r, y);
            ctx2.quadraticCurveTo(x + w2, y, x + w2, y + r);
            ctx2.lineTo(x + w2, y + h2 - r);
            ctx2.quadraticCurveTo(x + w2, y + h2, x + w2 - r, y + h2);
            ctx2.lineTo(x + r, y + h2);
            ctx2.quadraticCurveTo(x, y + h2, x, y + h2 - r);
            ctx2.lineTo(x, y + r);
            ctx2.quadraticCurveTo(x, y, x + r, y);
            ctx2.closePath();
          }

          roundRect2(rx, ry, rw, rh, 24);
          ctx2.fillStyle = "#f9fafb";
          ctx2.fill();
          ctx2.lineWidth = 2;
          ctx2.strokeStyle = "#e5e7eb";
          ctx2.stroke();

          ctx2.fillStyle = "#111827";
          ctx2.fillRect(rx, ry, rw, rh * 0.16);
          ctx2.fillStyle = "#f9fafb";
          ctx2.font = "bold 20px system-ui, sans-serif";
          ctx2.textBaseline = "middle";

          let title = "";
          if (stage === 1) title = "스타벅스 카라멜마키아또 [Tall]";
          else if (stage === 2) title = "스타벅스 아메리카노 + 디저트 세트";
          else title = "制作者 밥 사주는 쿠폰";

          ctx2.fillText(title, rx + 20, ry + rh * 0.08);

          ctx2.fillStyle = "#111827";
          ctx2.font = "16px system-ui, sans-serif";
          const midY = ry + rh * 0.42;
          let desc = "";
          if (stage === 1) {
            desc = "모바일 기프티콘 – 카라멜마키아또 Tall 1잔";
          } else if (stage === 2) {
            desc = "아메리카노 1잔 + 디저트 1종 세트";
          } else {
            desc = "제작자가 직접 사주는 식사 한 끼";
          }
          ctx2.fillText(desc, rx + 20, midY);

          const bcH = rh * 0.18;
          const bcY = ry + rh - bcH - 24;
          const bcX = rx + 24;
          const bcW = rw - 48;

          ctx2.fillStyle = "#e5e7eb";
          roundRect2(bcX, bcY, bcW, bcH, 12);
          ctx2.fill();
          ctx2.strokeStyle = "#d1d5db";
          ctx2.stroke();

          const colsM = 32;
          const rowsM = 6;
          const cellW = bcW / colsM;
          const cellH = bcH * 0.65 / rowsM;
          for (let iy = 0; iy < rowsM; iy++) {
            for (let ix = 0; ix < colsM; ix++) {
              const r = Math.random();
              if (r < 0.45) {
                ctx2.fillStyle = "#9ca3af";
              } else if (r < 0.75) {
                ctx2.fillStyle = "#6b7280";
              } else {
                ctx2.fillStyle = "#d1d5db";
              }
              ctx2.fillRect(bcX + ix * cellW, bcY + iy * cellH, cellW, cellH);
            }
          }

          const snY = bcY + bcH * 0.7;
          ctx2.fillStyle = "#e5e7eb";
          ctx2.fillRect(bcX, snY, bcW, bcH * 0.22);
          const snCols = 18;
          const snCellW = bcW / snCols;
          const snH = bcH * 0.22;
          for (let ix = 0; ix < snCols; ix++) {
            const r = Math.random();
            if (r < 0.5) ctx2.fillStyle = "#9ca3af";
            else ctx2.fillStyle = "#d1d5db";
            ctx2.fillRect(bcX + ix * snCellW, snY, snCellW * 0.8, snH * 0.75);
          }

          ctx2.save();
          ctx2.translate(rx + rw * 0.7, ry + rh * 0.35);
          ctx2.rotate(-Math.PI / 7);
          ctx2.strokeStyle = "#b91c1c";
          ctx2.fillStyle = "rgba(248,113,113,0.18)";
          ctx2.lineWidth = 3;
          roundRect2(-90, -26, 180, 52, 10);
          ctx2.fill();
          ctx2.stroke();
          ctx2.fillStyle = "#b91c1c";
          ctx2.font = "bold 20px system-ui, sans-serif";
          ctx2.textAlign = "center";
          ctx2.textBaseline = "middle";
          ctx2.fillText("사용완료", 0, 0);
          ctx2.restore();
        }

        ctx.drawImage(couponCanvas, 0, 0);
      }

      function draw() {
        drawCouponBackground();

        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = "rgba(31,41,55,0.7)";
        ctx.lineWidth = 0.5;

        for (let y = 0; y <= rows; y++) {
          const py = y * cellSize + 0.5;
          ctx.beginPath();
          ctx.moveTo(0, py);
          ctx.lineTo(canvas.width, py);
          ctx.stroke();
        }
        for (let x = 0; x <= cols; x++) {
          const px = x * cellSize + 0.5;
          ctx.beginPath();
          ctx.moveTo(px, 0);
          ctx.lineTo(px, canvas.height);
          ctx.stroke();
        }

        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const v = board[y][x];
            if (v === 1) {
              ctx.fillStyle = "rgba(16,185,129,0.12)";
            } else if (v === 2) {
              ctx.fillStyle = "#facc15";
            } else {
              continue;
            }
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }

        const rItem = cellSize * 0.7;
        for (const it of items) {
          const cx = it.x * cellSize + cellSize / 2;
          const cy = it.y * cellSize + cellSize / 2;
          if (it.type === "speed") {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.beginPath();
            ctx.moveTo(-rItem * 0.2, -rItem * 0.8);
            ctx.lineTo(rItem * 0.1, -rItem * 0.1);
            ctx.lineTo(-rItem * 0.1, -rItem * 0.1);
            ctx.lineTo(rItem * 0.2, rItem * 0.8);
            ctx.lineTo(-rItem * 0.1, rItem * 0.2);
            ctx.lineTo(0, rItem * 0.2);
            ctx.closePath();
            ctx.fillStyle = "#facc15";
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#fef9c3";
            ctx.stroke();
            ctx.restore();
          } else if (it.type === "life") {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.beginPath();
            const r = rItem * 0.7;
            ctx.moveTo(0, r);
            ctx.bezierCurveTo(-r, r * 0.4, -r, -r * 0.2, 0, -r * 0.4);
            ctx.bezierCurveTo(r, -r * 0.2, r, r * 0.4, 0, r);
            ctx.fillStyle = "#22c55e";
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#bbf7d0";
            ctx.stroke();
            ctx.restore();
          } else if (it.type === "enemy") {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.beginPath();
            ctx.moveTo(0, -rItem * 0.8);
            ctx.lineTo(rItem * 0.8, rItem * 0.8);
            ctx.lineTo(-rItem * 0.8, rItem * 0.8);
            ctx.closePath();
            ctx.fillStyle = "#f97316";
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ffedd5";
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, -rItem * 0.2);
            ctx.lineTo(0, rItem * 0.3);
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#1f2937";
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0, rItem * 0.5, rItem * 0.08, 0, Math.PI * 2);
            ctx.fillStyle = "#1f2937";
            ctx.fill();
            ctx.restore();
          }
        }

        for (const enemy of enemies) {
          const r = enemy.radius;
          if (enemy.type === 2) {
            const sides = 11;
            const step = (Math.PI * 2) / sides;
            const startAngle = -Math.PI / 2;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
              const ang = startAngle + step * i;
              const ex = enemy.x + Math.cos(ang) * r;
              const ey = enemy.y + Math.sin(ang) * r;
              if (i === 0) ctx.moveTo(ex, ey);
              else ctx.lineTo(ex, ey);
            }
            ctx.closePath();
            ctx.fillStyle = "#fb7185";
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#fecaca";
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, r, 0, Math.PI * 2);
            ctx.fillStyle = "#ef4444";
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#fee2e2";
            ctx.stroke();
          }
        }

        const px = player.x * cellSize + cellSize / 2;
        const py = player.y * cellSize + cellSize / 2;
        const pr = cellSize * 0.35;
        ctx.beginPath();
        ctx.arc(px, py, pr, 0, Math.PI * 2);
        ctx.fillStyle = "#e5e7eb";
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#38bdf8";
        ctx.stroke();
      }

      function showOverlay(title, sub, action) {
        overlayTitle.textContent = title;
        overlaySub.textContent = sub || "";
        overlay.style.display = "flex";
        pendingAction = action || null;
      }

      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = timestamp - lastTime;
        lastTime = timestamp;

        update(dt);
        draw();

        requestAnimationFrame(loop);
      }

      bindJoystick();
      startNewGame();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>

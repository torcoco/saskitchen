<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ÎïÖÎî∞Î¨µÍ∏∞: TITAN (BGM Ver)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      overscroll-behavior: none;
    }
    body {
      min-height: 100vh;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%, #000 100%);
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none;
    }
    .wrap {
      max-width: 960px;
      width: 100%;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      position: relative;
    }
    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.04em;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    .hud {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 13px;
    }
    .badge {
      padding: 6px 12px;
      border-radius: 8px;
      background: rgba(30, 41, 59, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.3);
      backdrop-filter: blur(4px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.2);
    }
    .game-shell {
      position: relative;
      display: inline-block;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7);
      border: 2px solid #374151;
    }
    canvas {
      background: #111;
      image-rendering: pixelated;
      display: block;
      max-width: 100%;
    }
    .loading-msg {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: #94a3b8;
      pointer-events: none;
      z-index: 5;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
    }
    .overlay-inner {
      pointer-events: auto;
      padding: 20px 30px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(56, 189, 248, 0.3);
      text-align: center;
      min-width: 260px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }
    .overlay-title {
      font-size: 20px;
      margin-bottom: 8px;
      color: #fff;
      font-weight: 700;
    }
    .overlay-sub {
      font-size: 14px;
      color: #cbd5e1;
      margin-bottom: 16px;
      white-space: pre-line;
      line-height: 1.4;
    }
    .overlay-inner button {
      padding: 8px 20px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s;
    }
    .overlay-inner button:active { transform: scale(0.95); }
    .start-layer {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      background: rgba(0,0,0,0.4);
      backdrop-filter: blur(2px);
    }
    .start-inner {
      pointer-events: auto;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 12px;
      border-radius: 12px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    #startButton {
      padding: 10px 24px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: #3b82f6;
    }
    #startButton:hover { background: #2563eb; }

    .joystick {
      margin-top: 16px;
      display: flex;
      justify-content: center;
      touch-action: none;
    }
    .stick-base {
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      position: relative;
      touch-action: none;
    }
    .stick-handle {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(56, 189, 248, 0.8);
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
      pointer-events: none;
    }
    .controls-hint {
      margin-top: 12px;
      font-size: 13px;
      color: #94a3b8;
      text-align: center;
      line-height: 1.5;
    }
    .key {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      background: #334155;
      color: #fff;
      font-family: monospace;
      font-weight: bold;
      border-bottom: 2px solid #1e293b;
    }
    #restartBtn {
      margin-top: 8px;
      padding: 8px 20px;
      border-radius: 99px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      background: #ef4444;
      color: white;
      font-weight: 600;
      display: none;
    }

    /* ÎÆ§Ìä∏ Î≤ÑÌäº Ïä§ÌÉÄÏùº */
    #muteBtn {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.2);
      background: rgba(15, 23, 42, 0.8);
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
    }
    #muteBtn:active {
      transform: scale(0.9);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ÎïÖÎî∞Î¨µÍ∏∞: <span style="color:#a855f7">TITAN</span></h1>
    
    <audio id="bgm" loop>
      <source src="./landwarbgm.mp3" type="audio/mp3">
    </audio>
    <button id="muteBtn">üîá</button>

    <div class="hud">
      <div class="badge">STAGE <span id="stage" style="color:#fbbf24">1</span></div>
      <div class="badge">SCORE <span id="score">0</span></div>
      <div class="badge">AREA <span id="fill" style="color:#34d399">0</span>% / <span id="target">80</span>%</div>
      <div class="badge">LIFE <span id="lives" style="color:#f87171">3</span></div>
    </div>

    <div class="game-shell">
      <canvas id="game" width="640" height="640"></canvas>
      <div class="loading-msg" id="loadingMsg">Ïù¥ÎØ∏ÏßÄ Î∂àÎü¨Ïò§Îäî Ï§ë...</div>

      <div class="overlay" id="overlay">
        <div class="overlay-inner">
          <div class="overlay-title" id="overlayTitle">Í≤∞Í≥º</div>
          <div class="overlay-sub" id="overlaySub">ÎÇ¥Ïö©</div>
          <button id="overlayRestart">Îã§Ïùå</button>
        </div>
      </div>

      <div class="start-layer" id="startLayer">
        <div class="start-inner">
          <button id="startButton">START GAME</button>
        </div>
      </div>
    </div>

    <div class="joystick" id="joystickArea">
      <div class="stick-base">
        <div class="stick-handle" id="stickHandle"></div>
      </div>
    </div>

    <div class="controls-hint">
      <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> ÎòêÎäî <span class="key">ÌôîÏÇ¥Ìëú</span><br>
      ÏùåÏïÖÍ≥º Ìï®ÍªòÌïòÎäî TITAN Î™®Îìú
    </div>

    <button id="restartBtn">Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú</button>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const bgCanvas = document.createElement("canvas");
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      const bgCtx = bgCanvas.getContext("2d");

      let revealImage = new Image();
      const loadingMsg = document.getElementById("loadingMsg");

      // --- Ïò§ÎîîÏò§ Í¥ÄÎ†® Î°úÏßÅ ---
      const bgm = document.getElementById("bgm");
      const muteBtn = document.getElementById("muteBtn");
      let isMuted = true;
      let soundStarted = false;

      bgm.volume = 0.4; // Î≥ºÎ•® 40%

      muteBtn.addEventListener("click", () => {
        isMuted = !isMuted;
        if(isMuted) {
          bgm.pause();
          muteBtn.textContent = "üîá";
        } else {
          bgm.play().catch(e => console.log(e));
          muteBtn.textContent = "üîä";
        }
      });

      function initAudio() {
        if (!soundStarted) {
          isMuted = false;
          muteBtn.textContent = "üîä";
          bgm.play().then(() => {
            soundStarted = true;
          }).catch(e => {
            console.log("Audio play failed (waiting for interaction):", e);
          });
        }
      }
      // -----------------------

      const cols = 80;
      const rows = 80;
      const cellSize = canvas.width / cols;

      const TARGET_PERCENT = 80;
      const MAX_LIVES = 3;
      
      const BASIC_SPEED = 5.0;            
      const BASIC_RADIUS = cellSize * 1.5; 
      
      const GIANT_SPEED = BASIC_SPEED / 5.0; 
      const GIANT_RADIUS = BASIC_RADIUS * 5.0; 

      const stageEl = document.getElementById("stage");
      const scoreEl = document.getElementById("score");
      const fillEl = document.getElementById("fill");
      const targetEl = document.getElementById("target");
      const livesEl = document.getElementById("lives");
      const restartBtn = document.getElementById("restartBtn");
      
      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlaySub = document.getElementById("overlaySub");
      const overlayRestart = document.getElementById("overlayRestart");
      
      const startLayer = document.getElementById("startLayer");
      const startButton = document.getElementById("startButton");

      targetEl.textContent = TARGET_PERCENT;

      let board; 
      let player = { x: 1, y: 0, trail: [] };
      let enemies = [];
      let score = 0;
      let lives = MAX_LIVES;
      let stage = 1;
      let running = false;

      const input = { x: 0, y: 0 };
      const keys = { w: false, a: false, s: false, d: false, up: false, left: false, down: false, right: false };

      function loadRandomImage() {
        loadingMsg.style.display = "block";
        revealImage = new Image();
        revealImage.crossOrigin = "Anonymous";
        const seed = Math.floor(Math.random() * 1000) + stage;
        revealImage.src = `https://picsum.photos/640/640?random=${seed}`;
        
        revealImage.onload = () => {
          loadingMsg.style.display = "none";
          renderStaticBoard();
        };
        revealImage.onerror = () => { loadingMsg.style.display = "none"; };
      }

      function renderStaticBoard() {
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        bgCtx.fillStyle = "#000000";
        bgCtx.beginPath();
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            if (board[y][x] === 1) {
              bgCtx.rect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
          }
        }
        bgCtx.fill();

        bgCtx.globalCompositeOperation = 'source-in';
        if (revealImage.complete && revealImage.naturalWidth > 0) {
           bgCtx.drawImage(revealImage, 0, 0, bgCanvas.width, bgCanvas.height);
        } else {
           bgCtx.fillStyle = "#10b981";
           bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        }
        bgCtx.globalCompositeOperation = 'source-over';

        bgCtx.strokeStyle = "rgba(255,255,255,0.05)";
        bgCtx.lineWidth = 0.5;
        bgCtx.beginPath();
        for(let x=0; x<=cols; x+=5) {
           bgCtx.moveTo(x*cellSize, 0); bgCtx.lineTo(x*cellSize, bgCanvas.height);
        }
        for(let y=0; y<=rows; y+=5) {
           bgCtx.moveTo(0, y*cellSize); bgCtx.lineTo(bgCanvas.width, y*cellSize);
        }
        bgCtx.stroke();
      }

      function updateInputVector() {
        let kx = 0, ky = 0;
        if (keys.a || keys.left) kx -= 1;
        if (keys.d || keys.right) kx += 1;
        if (keys.w || keys.up) ky -= 1;
        if (keys.s || keys.down) ky += 1;

        if (kx !== 0 || ky !== 0) {
          const len = Math.hypot(kx, ky);
          input.x = kx / len;
          input.y = ky / len;
        } 
      }

      function bindInputEvents() {
        window.addEventListener("keydown", e => {
          initAudio(); // [BGM] ÌÇ§Î≥¥Îìú ÏûÖÎ†• Ïãú Ïû¨ÏÉù
          const k = e.key.toLowerCase();
          if(k === 'w' || k === 'arrowup') keys.w = true;
          if(k === 'a' || k === 'arrowleft') keys.a = true;
          if(k === 's' || k === 'arrowdown') keys.s = true;
          if(k === 'd' || k === 'arrowright') keys.d = true;
          updateInputVector();
        });
        window.addEventListener("keyup", e => {
          const k = e.key.toLowerCase();
          if(k === 'w' || k === 'arrowup') keys.w = false;
          if(k === 'a' || k === 'arrowleft') keys.a = false;
          if(k === 's' || k === 'arrowdown') keys.s = false;
          if(k === 'd' || k === 'arrowright') keys.d = false;
          
          if (!keys.w && !keys.a && !keys.s && !keys.d) {
             const stickActive = document.querySelector(".stick-base").getAttribute("data-active") === "true";
             if(!stickActive) { input.x = 0; input.y = 0; }
          } else {
             updateInputVector();
          }
        });
      }

      function bindJoystick() {
        const base = document.querySelector(".stick-base");
        const handle = document.getElementById("stickHandle");
        let rect = base.getBoundingClientRect();
        let dragging = false;

        const updateStick = (clientX, clientY) => {
          const cx = rect.left + rect.width / 2;
          const cy = rect.top + rect.height / 2;
          const dx = clientX - cx;
          const dy = clientY - cy;
          const dist = Math.hypot(dx, dy);
          const maxDist = rect.width / 2;

          if (dist < 10) {
             input.x = 0; input.y = 0;
             handle.style.transform = `translate(-50%, -50%)`;
             return;
          }

          const angle = Math.atan2(dy, dx);
          input.x = Math.cos(angle);
          input.y = Math.sin(angle);

          const visualDist = Math.min(dist, maxDist);
          const vx = Math.cos(angle) * visualDist;
          const vy = Math.sin(angle) * visualDist;
          handle.style.transform = `translate(calc(-50% + ${vx}px), calc(-50% + ${vy}px))`;
        };

        const start = (e) => {
          initAudio(); // [BGM] Ï°∞Ïù¥Ïä§Ìã± ÌÑ∞Ïπò Ïãú Ïû¨ÏÉù
          dragging = true;
          base.setAttribute("data-active", "true");
          rect = base.getBoundingClientRect();
          const p = e.touches ? e.touches[0] : e;
          updateStick(p.clientX, p.clientY);
        };
        const move = (e) => {
          if (!dragging) return;
          e.preventDefault();
          const p = e.touches ? e.touches[0] : e;
          updateStick(p.clientX, p.clientY);
        };
        const end = () => {
          dragging = false;
          base.setAttribute("data-active", "false");
          input.x = 0; input.y = 0;
          handle.style.transform = `translate(-50%, -50%)`;
          updateInputVector();
        };

        base.addEventListener("mousedown", start);
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", end);
        base.addEventListener("touchstart", start, {passive:false});
        window.addEventListener("touchmove", move, {passive:false});
        window.addEventListener("touchend", end);
      }

      function createEmptyBoard() {
        const b = [];
        for (let y = 0; y < rows; y++) {
          const row = [];
          for (let x = 0; x < cols; x++) {
            if (y === 0 || y === rows - 1 || x === 0 || x === cols - 1) row.push(1);
            else row.push(0);
          }
          b.push(row);
        }
        return b;
      }

      function setupStage(s, hardReset) {
        if(hardReset) {
          score = 0;
          lives = MAX_LIVES;
        }
        board = createEmptyBoard();
        player.x = cols / 2;
        player.y = 0; 
        player.trail = [];
        player.drawing = false;

        spawnEnemies(s);
        loadRandomImage();
        updateHUD(0);
      }

      function spawnEnemies(s) {
        enemies = [];
        
        let basicCount = 0;
        let giantCount = 0;

        if (s === 1) {
            basicCount = 1; giantCount = 0;
        } else if (s === 2) {
            basicCount = 2; giantCount = 1;
        } else if (s === 3) {
            basicCount = 5; giantCount = 2;
        } else {
            basicCount = 5 + (s-3);
            giantCount = 2 + Math.floor((s-3)/2);
        }

        function createEnemy(type) {
            const angle = Math.random() * Math.PI * 2;
            const isGiant = (type === 'giant');
            const baseSpd = isGiant ? GIANT_SPEED : BASIC_SPEED;
            const radius = isGiant ? GIANT_RADIUS : BASIC_RADIUS;

            // [FIX] ÎûúÎç§ ÏúÑÏπò ÏÜåÌôò (Ï§ëÏïô Î∂ÄÍ∑º 50% ÏòÅÏó≠ ÎÇ¥) - 0,0 ÎÅºÏûÑ Î∞©ÏßÄ
            const range = 300; 
            const randX = (canvas.width/2) + (Math.random() - 0.5) * range;
            const randY = (canvas.height/2) + (Math.random() - 0.5) * range;

            return {
                type: type, 
                x: randX,
                y: randY,
                vx: Math.cos(angle) * baseSpd,
                vy: Math.sin(angle) * baseSpd,
                baseSpeed: baseSpd,
                radius: radius,
                rotation: 0,
                rotationDir: 1, 
            };
        }

        for(let i=0; i<giantCount; i++) enemies.push(createEnemy('giant'));
        for(let i=0; i<basicCount; i++) enemies.push(createEnemy('basic'));
      }

      function markPath(x0, y0, x1, y1) {
         let gridX0 = Math.floor(x0 + 0.5);
         let gridY0 = Math.floor(y0 + 0.5);
         let gridX1 = Math.floor(x1 + 0.5);
         let gridY1 = Math.floor(y1 + 0.5);

         const dx = Math.abs(gridX1 - gridX0);
         const dy = Math.abs(gridY1 - gridY0);
         const sx = (gridX0 < gridX1) ? 1 : -1;
         const sy = (gridY0 < gridY1) ? 1 : -1;
         let err = dx - dy;

         let loopCount = 0; 
         while(loopCount < 200) {
            loopCount++;
            
            if(gridX0 >= 0 && gridX0 < cols && gridY0 >= 0 && gridY0 < rows) {
               if(board[gridY0][gridX0] === 0) {
                  board[gridY0][gridX0] = 2;
                  player.trail.push({x: gridX0, y: gridY0});
               }
            }

            if (gridX0 === gridX1 && gridY0 === gridY1) break;
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; gridX0 += sx; }
            if (e2 < dx) { err += dx; gridY0 += sy; }
         }
      }

      function updatePlayer() {
        if (input.x === 0 && input.y === 0) return;

        const speed = BASIC_SPEED; 
        const nextX = player.x + input.x * speed * 0.1;
        const nextY = player.y + input.y * speed * 0.1;

        const nx = Math.floor(nextX + 0.5); 
        const ny = Math.floor(nextY + 0.5);
        if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return;

        const currGridX = Math.floor(player.x + 0.5);
        const currGridY = Math.floor(player.y + 0.5);
        const nextGridX = nx;
        const nextGridY = ny;

        let cellState = 0;
        if(currGridX>=0 && currGridX<cols && currGridY>=0 && currGridY<rows) {
           cellState = board[currGridY][currGridX];
        }

        if (!player.drawing) {
           if (cellState === 1 && board[nextGridY][nextGridX] === 1) {
             player.x = nextX;
             player.y = nextY;
           } 
           else if (board[nextGridY][nextGridX] === 0) {
             player.drawing = true;
             player.trail = []; 
             markPath(player.x, player.y, nextX, nextY);
             player.x = nextX;
             player.y = nextY;
           }
           else {
             player.x = nextX;
             player.y = nextY;
           }
        } else {
           markPath(player.x, player.y, nextX, nextY);
           player.x = nextX;
           player.y = nextY;

           if (board[nextGridY][nextGridX] === 1) {
             completeFill();
           }
           else if (board[nextGridY][nextGridX] === 2) {
             const trailIdx = player.trail.findIndex(t => t.x === nextGridX && t.y === nextGridY);
             if (trailIdx !== -1 && trailIdx < player.trail.length - 5) {
                loseLife();
             }
           }
        }
      }

      function checkCircleGridCollision(e) {
        const startX = Math.floor((e.x - e.radius) / cellSize);
        const endX = Math.floor((e.x + e.radius) / cellSize);
        const startY = Math.floor((e.y - e.radius) / cellSize);
        const endY = Math.floor((e.y + e.radius) / cellSize);

        if (startX >= cols || endX < 0 || startY >= rows || endY < 0) return true;

        for (let y = startY; y <= endY; y++) {
          for (let x = startX; x <= endX; x++) {
            let isWall = false;
            if (x < 0 || x >= cols || y < 0 || y >= rows) isWall = true;
            else if (board[y][x] === 1) isWall = true;

            if (isWall) {
              const cellX = x * cellSize;
              const cellY = y * cellSize;
              
              const closestX = Math.max(cellX, Math.min(e.x, cellX + cellSize));
              const closestY = Math.max(cellY, Math.min(e.y, cellY + cellSize));
              
              const dx = e.x - closestX;
              const dy = e.y - closestY;
              const distSq = dx * dx + dy * dy;

              if (distSq < e.radius * e.radius) {
                if (e.type === 'giant' && x>=0 && x<cols && y>=0 && y<rows && board[y][x] === 1) {
                   board[y][x] = 0;
                   renderStaticBoard(); 
                }
                return true;
              }
            }
          }
        }
        return false;
      }

      function updateEnemies() {
        for(let i=0; i<enemies.length; i++) {
            for(let j=i+1; j<enemies.length; j++) {
                const e1 = enemies[i];
                const e2 = enemies[j];
                const dx = e2.x - e1.x;
                const dy = e2.y - e1.y;
                let dist = Math.hypot(dx, dy);
                
                if (dist < 0.001) dist = 0.001; 

                const minDist = e1.radius + e2.radius;

                if (dist < minDist) {
                    const overlap = minDist - dist;
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    e1.x -= nx * overlap * 0.5;
                    e1.y -= ny * overlap * 0.5;
                    e2.x += nx * overlap * 0.5;
                    e2.y += ny * overlap * 0.5;

                    const v1n = e1.vx * nx + e1.vy * ny;
                    const v2n = e2.vx * nx + e2.vy * ny;

                    e1.vx += (v2n - v1n) * nx;
                    e1.vy += (v2n - v1n) * ny;
                    e2.vx += (v1n - v2n) * nx;
                    e2.vy += (v1n - v2n) * ny;
                    
                    applyRandomSpeed(e1);
                    applyRandomSpeed(e2);
                }
            }
        }

        enemies.forEach(e => {
          if(e.type === 'giant') {
              e.rotation += 0.02 * e.rotationDir;
          }

          e.x += e.vx;
          if (checkCircleGridCollision(e)) {
             e.x -= e.vx; 
             e.vx = -e.vx; 
             applyRandomSpeed(e);
             if(e.type === 'giant') e.rotationDir *= -1; 
          }

          e.y += e.vy;
          if (checkCircleGridCollision(e)) {
             e.y -= e.vy; 
             e.vy = -e.vy; 
             applyRandomSpeed(e);
             if(e.type === 'giant') e.rotationDir *= -1; 
          }
        });
      }

      function applyRandomSpeed(e) {
         const angle = Math.atan2(e.vy, e.vx);
         const newSpeed = e.baseSpeed * (0.8 + Math.random() * 0.4);
         e.vx = Math.cos(angle) * newSpeed;
         e.vy = Math.sin(angle) * newSpeed;
      }

      function checkCollisions() {
        if (!player.drawing) return;

        const px = player.x * cellSize;
        const py = player.y * cellSize;

        for (const e of enemies) {
          const dist = Math.hypot(e.x - px, e.y - py);
          if (dist < e.radius + cellSize) { 
            loseLife();
            return;
          }
          for (const t of player.trail) {
             const tx = t.x * cellSize + cellSize/2;
             const ty = t.y * cellSize + cellSize/2;
             if (Math.hypot(e.x - tx, e.y - ty) < e.radius + cellSize/2) {
                loseLife();
                return;
             }
          }
        }
      }

      function completeFill() {
        player.trail.forEach(p => board[p.y][p.x] = 1);
        player.drawing = false;
        player.trail = [];

        const regions = []; 
        const visited = Array(rows).fill(0).map(()=>Array(cols).fill(false));

        for(let y=0; y<rows; y++){
          for(let x=0; x<cols; x++){
             if(board[y][x] === 0 && !visited[y][x]) {
                const points = [];
                let q = [{x,y}];
                visited[y][x] = true;
                points.push({x,y});

                let head = 0;
                while(head < q.length){
                   const curr = q[head++];
                   [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
                      const nx = curr.x+dx;
                      const ny = curr.y+dy;
                      if(nx>=0 && nx<cols && ny>=0 && ny<rows &&
                         board[ny][nx]===0 && !visited[ny][nx]){
                         visited[ny][nx] = true;
                         q.push({x:nx, y:ny});
                         points.push({x:nx, y:ny});
                      }
                   });
                }
                regions.push(points);
             }
          }
        }

        if (regions.length > 1) {
            regions.sort((a, b) => b.length - a.length); 
            for(let i=1; i<regions.length; i++) {
                const region = regions[i];
                region.forEach(p => board[p.y][p.x] = 1);
                score += region.length * 10;
            }
        }

        renderStaticBoard();

        const initialCount = enemies.length;
        enemies = enemies.filter(e => {
           const gx = Math.floor(e.x / cellSize);
           const gy = Math.floor(e.y / cellSize);
           if(gy >= 0 && gy < rows && gx >= 0 && gx < cols) {
              return board[gy][gx] === 0;
           }
           return true; 
        });

        const killed = initialCount - enemies.length;
        if(killed > 0) {
            score += killed * 500;
        }
        
        const percent = getFillPercent();
        updateHUD(percent);
        
        if (percent >= TARGET_PERCENT) {
          running = false;
          showOverlay(`STAGE ${stage} CLEAR!`, "ÏôÑÎ≤ΩÌï©ÎãàÎã§!", () => {
             stage++;
             setupStage(stage, false);
             overlay.style.display = "none";
             running = true;
          });
        }
      }

      function getFillPercent() {
        let filled = 0;
        let total = (cols-2)*(rows-2);
        for(let y=1; y<rows-1; y++) {
           for(let x=1; x<cols-1; x++) {
              if(board[y][x] === 1) filled++;
           }
        }
        return (filled / total) * 100;
      }

      function loseLife() {
        lives--;
        player.trail.forEach(p => board[p.y][p.x] = 0);
        player.trail = [];
        player.drawing = false;
        player.x = cols/2; player.y = 0;
        
        updateHUD(getFillPercent());
        
        if (lives <= 0) {
          running = false;
          showOverlay("GAME OVER", `ÏµúÏ¢Ö Ï†êÏàò: ${score}`, () => {
            location.reload();
          });
        }
      }

      function updateHUD(pct) {
        fillEl.textContent = pct.toFixed(1);
        scoreEl.textContent = score;
        livesEl.textContent = lives;
        stageEl.textContent = stage;
      }

      function showOverlay(title, sub, callback) {
        overlayTitle.textContent = title;
        overlaySub.textContent = sub;
        overlay.style.display = "flex";
        overlayRestart.onclick = callback;
      }

      function loop() {
        if(running) {
          updatePlayer();
          updateEnemies();
          checkCollisions();
        }
        draw();
        requestAnimationFrame(loop);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.drawImage(bgCanvas, 0, 0);

        const px = player.x * cellSize;
        const py = player.y * cellSize;

        if (player.drawing) {
           ctx.strokeStyle = "#fbbf24";
           ctx.lineWidth = cellSize;
           ctx.lineCap = "round";
           ctx.lineJoin = "round";
           ctx.beginPath();
           if(player.trail.length > 0) {
             const start = player.trail[0];
             ctx.moveTo(start.x*cellSize + cellSize/2, start.y*cellSize + cellSize/2);
             for(let i=1; i<player.trail.length; i++){
                const t = player.trail[i];
                ctx.lineTo(t.x*cellSize + cellSize/2, t.y*cellSize + cellSize/2);
             }
             ctx.lineTo(px + cellSize/2, py + cellSize/2);
           }
           ctx.stroke();
        }

        ctx.fillStyle = "#38bdf8";
        ctx.beginPath();
        ctx.arc(px + cellSize/2, py + cellSize/2, cellSize*0.8, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();

        for(const e of enemies) {
           if (e.type === 'giant') {
              ctx.save();
              ctx.translate(e.x, e.y);
              ctx.rotate(e.rotation);
              ctx.beginPath();
              const sides = 10;
              for(let i=0; i<sides; i++) {
                 const theta = (i * 2 * Math.PI) / sides;
                 const ex = Math.cos(theta) * e.radius;
                 const ey = Math.sin(theta) * e.radius;
                 if(i===0) ctx.moveTo(ex, ey);
                 else ctx.lineTo(ex, ey);
              }
              ctx.closePath();
              ctx.fillStyle = "#a855f7"; 
              ctx.fill();
              ctx.lineWidth = 4;
              ctx.strokeStyle = "#e9d5ff";
              ctx.stroke();
              
              ctx.rotate(-e.rotation); 
              ctx.fillStyle = "#fff";
              ctx.beginPath();
              ctx.arc(-e.radius/3, -e.radius/3, e.radius/5, 0, Math.PI*2);
              ctx.arc(e.radius/3, -e.radius/3, e.radius/5, 0, Math.PI*2);
              ctx.fill();
              ctx.restore();

           } else {
              ctx.fillStyle = "#f87171";
              ctx.beginPath();
              ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
              ctx.fill();
              ctx.fillStyle = "#fff";
              ctx.beginPath();
              ctx.arc(e.x - e.radius/3, e.y - e.radius/3, e.radius/4, 0, Math.PI*2);
              ctx.arc(e.x + e.radius/3, e.y - e.radius/3, e.radius/4, 0, Math.PI*2);
              ctx.fill();
           }
        }
      }

      bindInputEvents();
      bindJoystick();
      
      startButton.addEventListener("click", () => {
        startLayer.style.display = "none";
        setupStage(1, true);
        running = true;
        loop();
      });

      restartBtn.addEventListener("click", () => location.reload());

    })();
  </script>
</body>
</html>
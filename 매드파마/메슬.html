<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Urban Alchemist - Real Assets</title>
    <style>
        body {
            margin: 0;
            background: #1a1a1a;
            display: flex;
            justify_content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #333; /* ì´ë¯¸ì§€ê°€ ë¡œë”© ì•ˆ ëì„ ë•Œ ê¸°ë³¸ ë°°ê²½ìƒ‰ */
            box-shadow: 0 0 60px rgba(0,0,0,0.6);
            border: 4px solid #444;
            border-radius: 4px;
            /* ë„íŠ¸ ì´ë¯¸ì§€ë¥¼ ì“´ë‹¤ë©´ ì„ ëª…í•˜ê²Œ, ê³ í•´ìƒë„ë¼ë©´ ë¶€ë“œëŸ½ê²Œ (ì·¨í–¥ê» ì¡°ì ˆ ê°€ëŠ¥) */
            image-rendering: pixelated; 
        }
        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.1rem;
            z-index: 10;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        .key {
            display: inline-block;
            background: #fff;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }
        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 20;
            border: 4px solid #ff4444;
            min-width: 320px;
        }
        #gameOverTitle {
            font-size: 3rem;
            color: #ff4444;
            margin-bottom: 15px;
            font-weight: bold;
            font-family: 'Impact', sans-serif;
        }
        #chargeBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            display: none;
            border: 2px solid #fff;
        }
        #chargeFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00FF7F, #32CD32);
        }
        button {
            font-size: 1.2rem; padding: 12px 30px; cursor: pointer;
            background: #ff4444; color: white; border: none; border-radius: 8px;
            font-weight: bold; transition: 0.2s;
        }
        button:hover { background: #ff6666; }
    </style>
</head>
<body>

    <div class="ui">
        <div style="margin-bottom: 8px;">ğŸƒ <span class="key">W</span> / <span class="key">Space</span> : JUMP</div>
        <div style="margin-bottom: 8px;">ğŸ§ª <span class="key">L</span> (Hold): CHARGE POTION</div>
        <div id="scoreBoard" style="margin-top: 10px; color: #FFD700; font-weight: bold;">TARGETS LEFT: 0</div>
    </div>

    <div id="chargeBar"><div id="chargeFill"></div></div>

    <div id="gameOverScreen">
        <div id="gameOverTitle">YOU DIED</div>
        <div style="color:#ccc; margin-bottom:20px;">Mission Failed.</div>
        <button onclick="location.reload()">RETRY</button>
    </div>

    <canvas id="gameCanvas" width="960" height="540"></canvas>

<script>
    // ==================================================================================
    // [ì˜í›ˆë‹˜ì„ ìœ„í•œ ì´ë¯¸ì§€ ì„¤ì • êµ¬ì—­]
    // * ë”°ì˜´í‘œ("") ì•ˆì— ì´ë¯¸ì§€ ì£¼ì†Œ(URL)ë¥¼ ë„£ì–´ì£¼ì„¸ìš”.
    // * ë¡œì»¬ íŒŒì¼ì€ ë¸Œë¼ìš°ì € ë³´ì•ˆìƒ ë°”ë¡œ ì“¸ ìˆ˜ ì—†ìœ¼ë‹ˆ, ì´ë¯¸ì§€ë¥¼ ì›¹(Imgur ë“±)ì— ì˜¬ë¦¬ê³  ì£¼ì†Œë¥¼ ë”°ì˜¤ë©´ í¸í•´.
    // * ì£¼ì†Œë¥¼ ë„£ì§€ ì•Šìœ¼ë©´(ë¹ˆì¹¸) ìë™ìœ¼ë¡œ 'ìƒ‰ê¹” ë°•ìŠ¤'ë¡œ í‘œì‹œë¼ì„œ ê²Œì„ì€ ê³„ì† í•  ìˆ˜ ìˆì–´.
    // ==================================================================================
    
    const imageUrls = {
        // 1. ìºë¦­í„° (ì˜¤ë¥¸ìª½ì„ ë³´ê³  ìˆëŠ” íˆ¬ëª… ë°°ê²½ PNG ì¶”ì²œ)
        player: "madp.png",  // ë§¤ë“œ ì‚¬ì´ì–¸í‹°ìŠ¤íŠ¸ ì´ë¯¸ì§€ ì£¼ì†Œ
        enemy: "",   // êµ­ì •ì› ìš”ì›/ì êµ° ì´ë¯¸ì§€ ì£¼ì†Œ

        // 2. ë°°ê²½ (960x540 ì‚¬ì´ì¦ˆ ê¶Œì¥)
        background: "background.png", // ê°•ë‚¨ëŒ€ë¡œ ë°°ê²½ ì´ë¯¸ì§€ ì£¼ì†Œ

        // 3. ì•„ì´í…œ & ì´í™íŠ¸
        potion: "",     // ë¬¼ì•½ ì´ë¯¸ì§€
        explosion: "",  // í­ë°œ ì´í™íŠ¸ ì´ë¯¸ì§€

        // 4. ì¥ì• ë¬¼ (ì—„íë¬¼)
        car: "car.png",     // ìŠ¹ìš©ì°¨
        stall: "nojum.png",   // ë…¸ì ìƒ
        vending: "", // ìíŒê¸°
        pot: "pot.png"      // í™”ë¶„
    };

    // ==================================================================================
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('scoreBoard');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const chargeBar = document.getElementById('chargeBar');
    const chargeFill = document.getElementById('chargeFill');

    // ì´ë¯¸ì§€ ë¡œë”© ì‹œìŠ¤í…œ
    const assets = {};
    for (const [key, url] of Object.entries(imageUrls)) {
        if (url && url.trim() !== "") {
            const img = new Image();
            img.src = url;
            assets[key] = img;
        }
    }

    // === ê²Œì„ ì„¤ì • ë³€ìˆ˜ ===
    const worldWidth = 8000; 
    const worldHeight = canvas.height;
    const gravity = 0.8;
    const baseGroundY = worldHeight - 80; 
    
    // ìºë¦­í„° í¬ê¸° (ì´ë¯¸ì§€ ë¹„ìœ¨ì— ë§ê²Œ ì¡°ì ˆ ê°€ëŠ¥)
    const charWidth = 60; 
    const charHeight = 90; 
    
    let gameFrame = 0; 
    let cameraX = 0;
    let gameOver = false;
    let chargeStartTime = 0;
    let isCharging = false;
    const maxChargeTime = 1000; 

    const keys = { w: false, a: false, s: false, d: false, l: false };
    const bumps = []; // ì§€í˜• ë‘”í„±

    // === ìœ í‹¸ë¦¬í‹° ===
    function checkCollision(rect1, rect2) {
        return (rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y);
    }
    
    function checkCircleRectCollision(circle, rect) {
        let distX = Math.abs(circle.x - rect.x - rect.width / 2);
        let distY = Math.abs(circle.y - rect.y - rect.height / 2);
        if (distX > (rect.width / 2 + circle.r)) return false;
        if (distY > (rect.height / 2 + circle.r)) return false;
        if (distX <= (rect.width / 2)) return true; 
        if (distY <= (rect.height / 2)) return true;
        let dx = distX - rect.width / 2;
        let dy = distY - rect.height / 2;
        return (dx * dx + dy * dy <= (circle.r * circle.r));
    }

    function getGroundY(x) {
        let groundY = baseGroundY;
        for(let bump of bumps) {
            if (x >= bump.x && x <= bump.x + bump.width) {
                let halfWidth = bump.width / 2;
                let center = bump.x + halfWidth;
                let distFromCenter = Math.abs(x - center);
                let heightAtX = bump.height * (1 - distFromCenter / halfWidth);
                groundY -= heightAtX;
                break;
            }
        }
        return groundY;
    }

    // === ë Œë”ë§ í•¨ìˆ˜ (ì´ë¯¸ì§€ ìœ„ì£¼) ===
    function drawSprite(ctx, img, x, y, w, h, direction = 1, rotation = 0) {
        const dx = x - cameraX;
        const dy = y;
        
        // í™”ë©´ ë°– ê·¸ë¦¬ê¸° ë°©ì§€
        if (dx < -w || dx > canvas.width + w) return;

        ctx.save();
        // ì¤‘ì‹¬ì¶• ì´ë™ (íšŒì „/ë°˜ì „ì„ ìœ„í•´)
        ctx.translate(dx + w / 2, dy + h / 2);
        
        if (direction === -1) ctx.scale(-1, 1); // ì¢Œìš° ë°˜ì „
        if (rotation !== 0) ctx.rotate(rotation);

        try {
            ctx.drawImage(img, -w / 2, -h / 2, w, h);
        } catch (e) {
            // ì´ë¯¸ì§€ ë¡œë“œ ì¤‘ ì—ëŸ¬ë‚˜ë©´ ë°•ìŠ¤ ê·¸ë¦¬ê¸°
            ctx.fillStyle = 'magenta';
            ctx.fillRect(-w / 2, -h / 2, w, h);
        }
        ctx.restore();
    }

    function drawCharacter(ctx, x, y, direction, isEnemy) {
        const img = isEnemy ? assets.enemy : assets.player;
        
        // ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        if (img && img.complete && img.naturalHeight !== 0) {
            drawSprite(ctx, img, x, y, charWidth, charHeight, direction);
        } else {
            // ì´ë¯¸ì§€ê°€ ì—†ìœ¼ë©´ ëŒ€ì²´ ë°•ìŠ¤ (Fallback)
            const dx = x - cameraX;
            if (dx < -100 || dx > canvas.width + 100) return;
            
            ctx.fillStyle = isEnemy ? '#333' : '#F5F5F5'; // ì :ê²€ì •, ë‚˜:í°ìƒ‰
            ctx.fillRect(dx, y, charWidth, charHeight);
            
            // ëˆˆ (ë°©í–¥ í‘œì‹œìš©)
            ctx.fillStyle = 'red';
            if(direction === 1) ctx.fillRect(dx + charWidth - 15, y + 10, 10, 10);
            else ctx.fillRect(dx + 5, y + 10, 10, 10);
            
            // ì´ë¦„í‘œ
            ctx.fillStyle = 'white';
            ctx.font = '12px sans-serif';
            ctx.fillText(isEnemy ? "AGENT" : "YOU", dx, y - 5);
        }
    }

    // === ë°°ê²½ ê·¸ë¦¬ê¸° ===
    class Background {
        draw() {
            // 1. ë°°ê²½ ì´ë¯¸ì§€
            if (assets.background && assets.background.complete && assets.background.naturalHeight !== 0) {
                // ë°°ê²½ì€ ì¹´ë©”ë¼ ì´ë™ì— ë”°ë¼ ì•½ê°„ ëŠë¦¬ê²Œ ì›€ì§ì„ (Parallax)
                let bgW = canvas.width; // í™”ë©´ ê½‰ ì±„ìš°ê¸°
                let bgH = canvas.height;
                
                // ë‹¨ìˆœ ë°˜ë³µ íŒ¨í„´ ëŒ€ì‹  í° ì´ë¯¸ì§€ í•˜ë‚˜ë¥¼ ê°€ì •í•˜ê±°ë‚˜, ë°˜ë³µ
                // ì—¬ê¸°ì„œëŠ” ë°˜ë³µìœ¼ë¡œ ì²˜ë¦¬
                let offsetX = (cameraX * 0.2) % bgW;
                
                ctx.drawImage(assets.background, -offsetX, 0, bgW, bgH);
                ctx.drawImage(assets.background, -offsetX + bgW, 0, bgW, bgH);
                if(-offsetX + bgW < canvas.width) ctx.drawImage(assets.background, -offsetX + bgW * 2, 0, bgW, bgH);
            
            } else {
                // ì´ë¯¸ì§€ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ í•˜ëŠ˜ìƒ‰ ë°°ê²½
                let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                grad.addColorStop(0, '#87CEEB'); grad.addColorStop(1, '#E0F7FA');
                ctx.fillStyle = grad; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#555';
                ctx.font = '20px sans-serif';
                ctx.fillText("ë°°ê²½ ì´ë¯¸ì§€ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš” (background)", 50, 100);
            }

            // 2. ë°”ë‹¥ (ì´ë¯¸ì§€ê°€ ìˆì–´ë„ ë°”ë‹¥ êµ¬ë¶„ì€ í•„ìš”í•¨)
            // íˆ¬ëª…ë„ê°€ ìˆëŠ” ê²€ì •ìƒ‰ìœ¼ë¡œ ì‚´ì§ ë®ì–´ì„œ í”Œë ˆì´ ì˜ì—­ í‘œì‹œ
            ctx.fillStyle = '#3E2723'; 
            ctx.fillRect(0, baseGroundY, canvas.width, worldHeight - baseGroundY);
            
            // ìƒë‹¨ ê²½ê³„ì„ 
            ctx.fillStyle = '#000';
            ctx.fillRect(0, baseGroundY, canvas.width, 4);

            // 3. ì§€í˜• ë‘”í„±
            for(let bump of bumps) {
                let drawBumpX = bump.x - cameraX;
                if (drawBumpX > canvas.width || drawBumpX + bump.width < 0) continue;
                
                ctx.fillStyle = '#5D4037'; 
                ctx.beginPath();
                ctx.moveTo(drawBumpX, baseGroundY);
                ctx.lineTo(drawBumpX + bump.width/2, baseGroundY - bump.height);
                ctx.lineTo(drawBumpX + bump.width, baseGroundY);
                ctx.fill();
                ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.stroke();
            }
        }
    }

    // === ì¥ì• ë¬¼ í´ë˜ìŠ¤ ===
    class Obstacle {
        constructor(x, type) {
            this.x = x; 
            this.type = type;
            // í¬ê¸° ì„¤ì •
            if (type === 'car') { this.width = 160; this.height = 60; } 
            else if (type === 'stall') { this.width = 120; this.height = 90; } 
            else if (type === 'vending') { this.width = 70; this.height = 80; } 
            else if (type === 'pot') { this.width = 45; this.height = 45; } 
            
            this.y = baseGroundY - this.height;
        }
        draw() {
            // í•´ë‹¹ íƒ€ì…ì˜ ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸
            const img = assets[this.type];
            
            if (img && img.complete && img.naturalHeight !== 0) {
                drawSprite(ctx, img, this.x, this.y, this.width, this.height);
            } else {
                // ì—†ìœ¼ë©´ ëŒ€ì²´ ë„í˜•
                const dx = this.x - cameraX;
                if (dx + this.width < -100 || dx > canvas.width + 100) return;
                
                if (this.type === 'car') ctx.fillStyle = 'red';
                else if (this.type === 'stall') ctx.fillStyle = 'brown';
                else if (this.type === 'vending') ctx.fillStyle = 'blue';
                else ctx.fillStyle = 'green';
                
                ctx.fillRect(dx, this.y, this.width, this.height);
                ctx.fillStyle = 'white';
                ctx.font = '10px sans-serif';
                ctx.fillText(this.type, dx + 5, this.y + 15);
            }
        }
    }

    // === ë¬¼ë¦¬ ì—”í‹°í‹° ===
    class PhysicsEntity {
        constructor(x, y, width, height) {
            this.x = x; this.y = y; this.width = width; this.height = height;
            this.vx = 0; this.vy = 0; this.grounded = false; this.direction = 1; this.gravityDirection = 1;
        }
        applyPhysics(obstacles) {
            let nextX = this.x + this.vx;
            if (nextX < 0) nextX = 0; if (nextX + this.width > worldWidth) nextX = worldWidth - this.width;
            let collisionX = false;
            obstacles.forEach(obs => { 
                if (checkCollision({x: nextX, y: this.y, width: this.width, height: this.height}, obs)) collisionX = true; 
            });
            if (!collisionX) this.x = nextX; else this.vx = 0;

            this.vy += gravity * this.gravityDirection; 
            let nextY = this.y + this.vy;
            this.grounded = false;

            obstacles.forEach(obs => {
                if (this.vy > 0 && this.x + this.width > obs.x + 5 && this.x < obs.x + obs.width - 5 && this.y + this.height <= obs.y && nextY + this.height >= obs.y) {
                    nextY = obs.y - this.height; this.vy = 0; this.grounded = true;
                }
                if (this.vy < 0 && this.x + this.width > obs.x + 5 && this.x < obs.x + obs.width - 5 && this.y >= obs.y + obs.height && nextY <= obs.y + obs.height) {
                    nextY = obs.y + obs.height; this.vy = 0;
                }
            });
            let groundLevel = getGroundY(this.x + this.width/2);
            if (!this.grounded && nextY + this.height > groundLevel && this.gravityDirection > 0) {
                nextY = groundLevel - this.height; this.vy = 0; this.grounded = true;
            }
            this.y = nextY;
        }
    }

    class Player extends PhysicsEntity {
        constructor() { super(50, 0, charWidth, charHeight); this.speed = 6; this.jumpPower = -17; }
        update(obstacles) {
            if (keys.d) { this.vx = this.speed; this.direction = 1; }
            else if (keys.a) { this.vx = -this.speed; this.direction = -1; }
            else { this.vx = 0; }
            if (keys.w && this.grounded) { this.vy = this.jumpPower; this.grounded = false; }
            this.applyPhysics(obstacles);
            
            let targetCamX = this.x - canvas.width / 2 + this.width / 2;
            if (targetCamX < 0) targetCamX = 0; if (targetCamX > worldWidth - canvas.width) targetCamX = worldWidth - canvas.width;
            cameraX += (targetCamX - cameraX) * 0.1;
        }
        draw() { drawCharacter(ctx, this.x, this.y, this.direction, false); }
    }

    class Enemy extends PhysicsEntity {
        constructor(startX) {
            super(startX, 0, charWidth, charHeight);
            this.speed = 3.5; this.isActive = false; this.viewDistance = 850;
            this.isHit = false; this.shootTimer = 0; this.jumpPower = -17;
        }
        update(obstacles, player) {
            if (this.isHit) {
                this.gravityDirection = -0.5; this.vx = 0; 
                this.applyPhysics(obstacles); if(this.y < -200) this.markedForDeletion = true; return; 
            }
            const dist = Math.abs(player.x - this.x);
            if (!this.isActive && dist < this.viewDistance) this.isActive = true;
            if (this.isActive) {
                if (player.x > this.x + 10) { this.vx = this.speed; this.direction = 1; }
                else if (player.x < this.x - 10) { this.vx = -this.speed; this.direction = -1; }
                else { this.vx = 0; }
                
                if (this.grounded && this.vx !== 0) {
                    let checkDist = 60; let checkX = this.direction === 1 ? this.x + this.width + checkDist : this.x - checkDist;
                    let jumpNeeded = false;
                    for(let obs of obstacles) {
                        if (checkX > obs.x && checkX < obs.x + obs.width && this.y + this.height > obs.y + 10) { jumpNeeded = true; break; }
                    }
                    if(jumpNeeded) { this.vy = this.jumpPower; this.grounded = false; }
                }
                this.shootTimer++;
                if (this.shootTimer % 90 === 0) { bullets.push(new Bullet(this.x, this.y + 35, this.direction)); }
            }
            this.applyPhysics(obstacles);
        }
        draw() { drawCharacter(ctx, this.x, this.y, this.direction, true); }
    }

    class Potion {
        constructor(x, y, direction, powerRatio) {
            this.x = x; this.y = y; this.width = 24; this.height = 24;
            const minVx = 3; const maxVx = 25; const minVy = -6; const maxVy = -20;
            this.vx = (minVx + (maxVx - minVx) * powerRatio) * direction;
            this.vy = minVy + (maxVy - minVy) * powerRatio;
            this.markedForDeletion = false; this.rotation = 0;
        }
        update(obstacles) {
            this.vy += gravity; this.x += this.vx; this.y += this.vy; this.rotation += 0.2;
            let groundLevel = getGroundY(this.x + this.width/2);
            if (this.y + this.height > groundLevel) { this.explode(); return; }
            obstacles.forEach(obs => { if(checkCollision(this, obs)) { this.explode(); } });
        }
        explode() {
            this.markedForDeletion = true; explosions.push(new Explosion(this.x + this.width/2, this.y + this.height/2));
        }
        draw() {
            if (assets.potion && assets.potion.complete) {
                drawSprite(ctx, assets.potion, this.x, this.y, this.width, this.height, 1, this.rotation);
            } else {
                // ëŒ€ì²´: ë³´ë¼ìƒ‰ êµ¬
                const dx = this.x - cameraX;
                ctx.save(); ctx.translate(dx + this.width/2, this.y + this.height/2); ctx.rotate(this.rotation);
                ctx.fillStyle = '#00FF7F'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }
    }

    class Explosion {
        constructor(x, y) {
            this.x = x; this.y = y; this.radius = 0; this.maxRadius = 70; this.opacity = 1; this.markedForDeletion = false;
        }
        update() { this.radius += 5; this.opacity -= 0.05; if (this.opacity <= 0) this.markedForDeletion = true; }
        draw() {
            if (assets.explosion && assets.explosion.complete) {
                // í­ë°œ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ì¤‘ì‹¬ ê¸°ì¤€ í™•ëŒ€)
                const size = this.radius * 2;
                drawSprite(ctx, assets.explosion, this.x - this.radius, this.y - this.radius, size, size);
            } else {
                // ëŒ€ì²´: ë…¹ìƒ‰ ì›
                const dx = this.x - cameraX;
                ctx.save(); ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#00C853'; ctx.beginPath(); ctx.arc(dx, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }
    }

    class Bullet {
        constructor(x, y, direction) {
            this.x = x; this.y = y; this.width = 12; this.height = 6; this.speed = 14; this.direction = direction; this.markedForDeletion = false;
        }
        update(obstacles) {
            this.x += this.speed * this.direction;
            if (this.x < cameraX - 100 || this.x > cameraX + canvas.width + 100) this.markedForDeletion = true;
            obstacles.forEach(obs => { if(checkCollision(this, obs)) this.markedForDeletion = true; });
        }
        draw() { 
            const dx = this.x - cameraX; 
            ctx.fillStyle = '#FFD700'; ctx.fillRect(dx, this.y, this.width, this.height);
        }
    }

    // === ì‹¤í–‰ (Initialization) ===
    const player = new Player();
    const bg = new Background();
    let potions = [], bullets = [], enemies = [], obstacles = [], explosions = [];

    function init() {
        gameFrame = 0; potions = []; bullets = []; explosions = []; gameOver = false;
        player.x = 50; player.y = 0; cameraX = 0;
        
        bumps.length = 0; let bumpX = 300;
        while(bumpX < worldWidth) { bumps.push({ x: bumpX, width: 100 + Math.random()*100, height: 30 + Math.random()*30 }); bumpX += 400 + Math.random()*400; }

        obstacles = []; let curX = 500;
        while(curX < worldWidth - 500) {
            let r = Math.random(); let type = r < 0.3 ? 'car' : (r < 0.5 ? 'stall' : (r < 0.7 ? 'vending' : 'pot'));
            obstacles.push(new Obstacle(curX, type)); curX += Math.random() * 250 + 200; 
        }

        enemies = [];
        for (let i = 0; i < 20; i++) { enemies.push(new Enemy(800 + Math.random() * (worldWidth - 1000))); }
        scoreBoard.innerText = 'TARGETS LEFT: ' + enemies.length;
        gameOverScreen.style.display = 'none';
        animate();
    }

    window.addEventListener('keydown', (e) => {
        if (gameOver) return;
        let code = e.code;
        if (code === 'KeyD') keys.d = true; if (code === 'KeyA') keys.a = true; if (code === 'KeyW' || code === 'Space') keys.w = true; 
        if (code === 'KeyL' && !isCharging) { isCharging = true; chargeStartTime = Date.now(); chargeBar.style.display = 'block'; }
    });
    
    window.addEventListener('keyup', (e) => {
        let code = e.code;
        if (code === 'KeyD') keys.d = false; if (code === 'KeyA') keys.a = false; if (code === 'KeyW' || code === 'Space') keys.w = false;
        if (code === 'KeyL' && isCharging) {
            isCharging = false; chargeBar.style.display = 'none'; chargeFill.style.width = '0%';
            if (gameOver) return;
            const chargeDuration = Date.now() - chargeStartTime;
            let powerRatio = Math.min(chargeDuration, maxChargeTime) / maxChargeTime;
            let potionX = player.direction === 1 ? player.x + charWidth : player.x - 10;
            potions.push(new Potion(potionX, player.y + 20, player.direction, powerRatio));
        }
    });

    function animate() {
        if (gameOver) return;
        if (isCharging) {
            const chargeDuration = Date.now() - chargeStartTime;
            let p = Math.min(chargeDuration, maxChargeTime) / maxChargeTime * 100;
            chargeFill.style.width = p + '%';
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        bg.draw();
        obstacles.forEach(obs => obs.draw());
        player.update(obstacles); 
        drawCharacter(ctx, player.x, player.y, player.direction, false);

        potions.forEach((potion, i) => { potion.update(obstacles); potion.draw(); if (potion.markedForDeletion) potions.splice(i, 1); });
        explosions.forEach((exp, i) => { exp.update(); exp.draw(); if(exp.markedForDeletion) explosions.splice(i, 1); });
        bullets.forEach((bullet, i) => {
            bullet.update(obstacles); bullet.draw();
            if(checkCollision(bullet, player)) { gameOver = true; gameOverScreen.style.display = 'block'; }
            if (bullet.markedForDeletion) bullets.splice(i, 1);
        });
        enemies.forEach((enemy, eIndex) => {
            enemy.update(obstacles, player); 
            drawCharacter(ctx, enemy.x, enemy.y, enemy.direction, true);
            if (!enemy.isHit) {
                explosions.forEach(exp => {
                    if (checkCircleRectCollision({x: exp.x, y: exp.y, r: exp.maxRadius}, enemy)) {
                        enemy.isHit = true; scoreBoard.innerText = 'TARGETS LEFT: ' + (enemies.filter(e => !e.isHit).length);
                    }
                });
            }
            if (enemy.markedForDeletion) { enemies.splice(eIndex, 1); }
        });
        gameFrame++; requestAnimationFrame(animate);
    }
    init();

</script>
</body>
</html>
